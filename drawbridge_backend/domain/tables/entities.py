import dataclasses
import datetime
from typing import Any, Generic, TypeVar

from drawbridge_backend.domain.enums import DataTypeEnum


@dataclasses.dataclass
class OrderingParam:
    field_id: int
    ascending: bool = True


@dataclasses.dataclass
class FilteringParam:
    field_id: int
    value: str


@dataclasses.dataclass
class BaseValue:
    value: Any


@dataclasses.dataclass
class IntValue(BaseValue):
    value: int

    @property
    def data_type(self) -> DataTypeEnum:
        return DataTypeEnum.INT


@dataclasses.dataclass
class StringValue(BaseValue):
    value: str

    @property
    def data_type(self) -> DataTypeEnum:
        return DataTypeEnum.STRING


@dataclasses.dataclass
class BoolValue(BaseValue):
    value: bool

    @property
    def data_type(self) -> DataTypeEnum:
        return DataTypeEnum.BOOL


@dataclasses.dataclass
class FloatValue(BaseValue):
    value: float

    @property
    def data_type(self) -> DataTypeEnum:
        return DataTypeEnum.FLOAT


@dataclasses.dataclass
class DateTimeValue(BaseValue):
    value: datetime.datetime

    @property
    def data_type(self) -> DataTypeEnum:
        return DataTypeEnum.DATETIME


VT = TypeVar("VT", bound=BaseValue, contravariant=False)


@dataclasses.dataclass
class RowData(Generic[VT]):
    field_id: int
    value: VT

    @property
    def data_type(self) -> DataTypeEnum:
        return self.value.data_type # type:ignore


@dataclasses.dataclass
class Row:
    table: "Table"
    # pk of the row always auto-generated by service on insert
    row_id: int
    values: list[RowData[BaseValue]]


@dataclasses.dataclass
class InsertRow:
    table: "Table"
    values: list[RowData[BaseValue]]


@dataclasses.dataclass
class UpdateRow:
    table: "Table"
    row_id: int
    new_values: list[RowData[BaseValue]]


@dataclasses.dataclass
class Field:
    _field_id: int
    name: str
    verbose_name: str
    data_type: DataTypeEnum
    is_nullable: bool
    default_value: str | None = None

    @property
    def field_id(self) -> int:
        return self._field_id

    @field_id.setter
    def field_id(self, value: int) -> None:
        raise AttributeError("field_id is read-only")


@dataclasses.dataclass
class UnSavedField:
    name: str
    verbose_name: str
    data_type: DataTypeEnum
    is_nullable: bool
    default_value: str | None = None


@dataclasses.dataclass
class Table:
    table_id: int
    name: str
    fields: list[Field]
    verbose_name: str | None = None
    description: str | None = None

    def get_field_by_id(self, field_id: int) -> Field | None:
        for f in self.fields:
            if f.field_id == field_id:
                return f

        return None

    def get_field_by_name(self, field_name: str) -> Field:
        for f in self.fields:
            if f.name == field_name:
                return f

        raise ValueError("Field with name=%s is not exists")


@dataclasses.dataclass
class UnSavedTable:
    name: str
    fields: list[UnSavedField]
    verbose_name: str | None = None
    description: str | None = None
